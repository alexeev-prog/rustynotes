 В Rust существует все популярные типы данных, с учетом того что Rust - в основном системный и низкоуровневый язык.

Типы данных бывают следующие:
## Числа

### Целые и десятичные числа

Для создания целых чисел и чисел с плавающей точкой в Rust применяется традиционный синтаксис. В операциях с числами применяется инфиксная нотация, означающая, что числовые выражения выглядят так, как многие привыкли их видеть в большинстве языков программирования. При работе с несколькими типами в Rust допускается применение для сложения одного и того же знака. Этот прием называется *перегрузкой операторов*.

1. В языке Rust имеется большое количество числовых типов. У вас выработается привычка объявлять размер в байтах, что окажет влияние на количество чисел, представляемых типом, и на то, сможет ли он предоставить отрицательные значения.
2. Преобразования между типами всегда носят явный характер. Rust не производит автоматическое преобразование 16-разрядного целого числа в 32-разрядное.
3. В Rust у чисел могут быть методы. Например для округления 24.5 к ближайшему числу Rust-программисты используют не традиционных подход (`round(24.5_f32)`), а вызов метода `24.5_f32.round()`. Здесь наличие суффикса типа объясняется необходимостью указания конкретного типа.

```rust
fn main() {
	let twenty = 20;
	let twenty_one: i32 = 21;
	let twenty_two = 22_i32;
	let addition = twenty + twenty_one + twenty_two;
	
	println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);
	
	let one_million: i64 = 1_000_000;
	println!("{}", one_million.pow(2));

	let forty_twos = [
		42.0,
		42f32,
		42.0_f32
	];

	println!("{:02}", forty_twos[0]);
}
```

### Записи чисел с основанием 2, 8 и 16
В Rust также имеется встроенная поддержка числовых литералов, позволяющих определять целые числа по основанию 2 (двоичные), по основанию 8 (восьмеричные) и по основанию 16 (шестнадцатеричные). Эта нотация также доступна при форматировании таких макросов, как `println!`.

```rust
fn main() {
	let three = 0b11;
	let thirty = 0o36;
	let three_hundred = 0x12C;
	
	println!("base 10: {} {} {}", three, thirty, three_hundred);
	println!("base 2: {:b} {:b} {:b}", three, thirty, three_hundred);
	println!("base 8: {:o} {:o} {:o}", three, thirty, three_hundred);
	println!("base 16: {:x} {:x} {:x}", three, thirty, three_hundred);
}
```

В двоичных (по основанию 2) записях чисел `0b11` равно 3, поскольку 3 = 2 * 1 + 1 * 1. В восьмеричных (по основанию 8) записях чисел `0o36` равно 30, поскольку 30 = 8 * 3 + 1 * 6. А в шестнадцатеричных (по основанию 16) записях чисел `0x12C` равно 300, поскольку 300 = 256 * 1 + 16 * 2 + 1 * 12. Типы, представляющие скалярные числа, показаны в таблицу ниже:

| Тип                   | Описание                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| u8, u16, u32, u64     | Целые числа без знака в диапазоне от 8 до 64 разрядов                                                                                                                    |
| i8, i16, i32, i64<br> | Целые числа со знаком в диапазоне от 8 до 64 разрядов                                                                                                                    |
| f32, f64              | Числа с плавающей точкой в 32-разрядном и 64-разрядном вариантах                                                                                                         |
| isize, usize          | Целые числа, предполагающие "исходную" разрядность центрального процессора. Например, в 64-разрядных центральных процессорах `usize` и `isize` будут шириной 64-разряда. |
 Целые числа со знаком (`i`) представляют собой как отрицательные, так и положительные целые числа.
 Целые числа без знака (`u`) представляют собой только положительные целые числа, но могут быть вдвое шире обычных чисел.
 Типы с плавающей точкой (`f`) представляют собой действительные числа со специальными комбинациями битов для представления значений бесконечности и "не числа".
Ширина целочисленного значения - это количество битов, используемых типом в оперативной памяти или в центральном процессоре.

### Невозможность проведения сравнения разных типов
В Rust существуют требования к безопасности типов, которые не позволяют проводить сравнение между переменными разного типа.

Чтобы компилятор смог сравнить, надо будет воспользоваться оператором `as` для приведения операнда одного типа к другому типу. Например:

```rust
// Код ниже не пройдет компиляцию
fn main() {
	let a: i32 = 10;
	let b: u16 = 100;

	if a < b {
		println!("Ten is less than one hundred.")
	}
}

// Код ниже пройдет компиляцию
fn main() {
	let a: i32 = 10;
	let b: u16 = 100;

	if a < (b as i32) {
		println!("Ten is less than one hundred.")
	}
}
```

Безопаснее всего привести меньший тип к большему (например, 16-разрядный тип к 32-разрядному типу).

Порой использование ключевого слова `as` накладывает слишком больше ограничения. Восстановить более полный контроль над приведением типов можно за счет ряда формальностей. Это выполняет типаж [[TryInto]]:

```rust
use std::convert::TryInto;

fn main() {
	let a: i32 = 10;
	let b: u16 = 100;

	let b_ = b.try_into().unwrap();

	if a < b_ {
		println!("Ten is less than one hundred");
	}
}
```

### Опасности чисел с плавающей точкой
Типы чисел с плавающей точкой (например, `f32` и `f64`) по неосмотрительности могут возникать серьезные проблемы. Этому есть по крайней мере две причины:

1. Зачастую они соответствуют представляемым числам только приблизительно. Типы с плавающей точкой реализованы числами по основанию 2, но вычисления довольно часто требуется проводить в числах по основанию 10. Это несоответствие создает неопределенность. И еще, хотя значения с плавающей точкой описываются как представляющие действительные числа, они имеют ограниченную точность. Для представления всех действительных чисел требуется бесконечная точность.
2. Они могут представлять значения, семантика которых не воспринимается на интуитивном уровне. В отличии от целых чисел, типы с плавающей точкой имеют ряд значений, которые (конструктивно) плохо сочетаются друг с другом. Формально у них только частичное отношение эквивалентности. Все это запрограммировано в системе типов Rust. Для типов `f32` и `f64` реализован только [[Типаж]] `std::cmp::PartialEq`, а для других числовых типов реализован также [[Типаж]] `std::cmp::Eq`.

Для предотвращения опасностей нужно следовать двум рекомендациям:

1. Избегать проверок чисел с плавающей точкой на равенство.
2. Проявлять осторожность, когда результаты могут быть математически неопределенными.

Использование равенства для сравнения чисел с плавающей точкой может быть весьма проблематичным. Числа с плавающей точкой реализованы компьютерными системами, использующие двоичную математику, но от них часто требуется выполнять операции над десятичными числами.

### Рациональные, комплексные и другие
Стандартная библиотека Rust сравнительно невелика по объему. В нее не включены числовые типы, которые часто доступны в других языках. К ним относятся:

 + Многие математические объекты для работы с рациональными и комплексными числами.
 + Целые числа произвольного размера и числа с плавающей точкой произвольной точности для работы с очень большими или маленькими числами.
 + Десятичные числа с фиксированной точкой для работы с валютами.

Для доступа к этим особым числовым типам можно воспользоваться [[Контейнер]]ами или крейтами.

```bash
cargo add num
```

Или отредактируйте файл `Cargo.toml`:

```toml
[dependencies]
num = "0.4"
```

```rust
use num::complex::Complex;

fn main() {
    let a = Complex{re: 1.1, im: -1.2};
    let b = Complex::new(10.1, 22.2);
    let result = a + b;

    println!("{} + {}", result.re, result.im);
}
```

## Логический тип данных
Как и в большинстве других языков программирования, логический тип в Rust имеет два возможных значения: `true` и `false`. Значения логических типов имеют размер в один байт. Логический тип в Rust задаётся с помощью `bool`. Например:

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

## Символьный тип данных
Тип `char` в Rust является самым примитивным алфавитным типом языка. Вот несколько примеров объявления значений `char`:

```rust
fn main() {
    let c = '0';
    let z: char = '0'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```

Как и во многих других языках, символ задается в одинарных кавычках. Символ имеет размер в 4 байта и представляет собой скалярное значение Unicode. То есть, данный тип поддерживает практически любой тип символов: от иероглифов до эмодзи. Скалярные значения Unicode находятся в диапазоне от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно.

## Составные типы данных
Составные типы позволяют группировать различные элементы в один тип. В Rust составных типов существует двое: массивы и кортежи.

### Кортежи
_Кортеж_ - это универсальный способ объединения нескольких значений с различными типами в один составной тип. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

Переменная `tup` связана со всем кортежем, поскольку кортеж является одним составным элементом. Чтобы получить отдельные значения из кортежа, можно использовать сопоставление с образцом для деструктуризации значения кортежа, например, так:

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

Мы также можем получить доступ к элементу кортежа напрямую, используя точку (`.`), за которой следует индекс значения, требуемого для доступа (в других языках программирования аналогично `tuple[index]`. Например:

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0; // 500
    let six_point_four = x.1; // 6.4
    let one = x.2; // 1
}
```

Кортеж, не имеющий значений, имеет специальное имя _единичный тип (unit)_. Это значение и соответствующий ему тип записываются как `()` и представляет собой пустое значение или пустой возвращаемый тип. Выражения неявно возвращают значение единичного типа, если не возвращают никакого другого значения.

### Массивы
В отличии от кортежей, все элементы должны иметь один тип данных. В отличие от массивов в некоторых других языках, массивы в Rust имеют фиксированную длину.

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

Массивы удобно использовать в LIFO-стеках (last in, first out - последний зашел, первый вышел).

Также, если вам нужен массив с нефиксированной длиной, можно воспользоваться _векторами_ (аналогичный тип коллекции, предоставляемый стандартной библиотекой, который _может_ увеличиваться или уменьшаться в размере).

Тип массива записывается следующим образом: в квадратных скобках обозначается тип элементов массива, а затем, через точку с запятой, количество элементов. Например:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

Вы также можете инициализировать массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо типа. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:

```rust
let a = [3; 5];
```

Этот код создаст массив из 5 элементов, причем каждый из них будет равен 3. Данная запись аналогична `let a = [3, 3, 3, 3, 3];`.

Массив — это единый фрагмент памяти известного фиксированного размера, который может быть размещён в стеке. Вы можете получить доступ к элементам массива с помощью индексации, например:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0]; // 1
    let second = a[1]; // 2
}
```

Также, в Rust осуществляется проверка на обращение к элементу вне диапазона массива. Например, к 7 элементу массива из 5 элементов. Rust проверяет это на этапе выполнения, т.к. компилятор не может заранее знать как будет идти обращение, и в случае некорректного доступа приложение "запаникует".

Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный индекс, доступ к памяти может быть некорректным. Rust защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу.