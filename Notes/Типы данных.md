 В Rust существует все популярные типы данных, с учетом того что Rust - в основном системный и низкоуровневый язык.

Типы данных бывают следующие:

## Числа

### Целые и десятичные числа

Для создания целых чисел и чисел с плавающей точкой в Rust применяется традиционный синтаксис. В операциях с числами применяется инфиксная нотация, означающая, что числовые выражения выглядят так, как многие привыкли их видеть в большинстве языков программирования. При работе с несколькими типами в Rust допускается применение для сложения одного и того же знака. Этот прием называется *перегрузкой операторов*.

1. В языке Rust имеется большое количество числовых типов. У вас выработается привычка объявлять размер в байтах, что окажет влияние на количество чисел, представляемых типом, и на то, сможет ли он предоставить отрицательные значения.
2. Преобразования между типами всегда носят явный характер. Rust не производит автоматическое преобразование 16-разрядного целого числа в 32-разрядное.
3. В Rust у чисел могут быть методы. Например для округления 24.5 к ближайшему числу Rust-программисты используют не традиционных подход (`round(24.5_f32)`), а вызов метода `24.5_f32.round()`. Здесь наличие суффикса типа объясняется необходимостью указания конкретного типа.

```rust
fn main() {
	let twenty = 20;
	let twenty_one: i32 = 21;
	let twenty_two = 22_i32;
	let addition = twenty + twenty_one + twenty_two;
	
	println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);
	
	let one_million: i64 = 1_000_000;
	println!("{}", one_million.pow(2));

	let forty_twos = [
		42.0,
		42f32,
		42.0_f32
	];

	println!("{:02}", forty_twos[0]);
}
```

### Записи чисел с основанием 2, 8 и 16
В Rust также имеется встроенная поддержка числовых литералов, позволяющих определять целые числа по основанию 2 (двоичные), по основанию 8 (восьмеричные) и по основанию 16 (шестнадцатеричные). Эта нотация также доступна при форматировании таких макросов, как `println!`.

```rust
fn main() {
	let three = 0b11;
	let thirty = 0o36;
	let three_hundred = 0x12C;
	
	println!("base 10: {} {} {}", three, thirty, three_hundred);
	println!("base 2: {:b} {:b} {:b}", three, thirty, three_hundred);
	println!("base 8: {:o} {:o} {:o}", three, thirty, three_hundred);
	println!("base 16: {:x} {:x} {:x}", three, thirty, three_hundred);
}
```

В двоичных (по основанию 2) записях чисел `0b11` равно 3, поскольку 3 = 2 * 1 + 1 * 1. В восьмеричных (по основанию 8) записях чисел `0o36` равно 30, поскольку 30 = 8 * 3 + 1 * 6. А в шестнадцатеричных (по основанию 16) записях чисел `0x12C` равно 300, поскольку 300 = 256 * 1 + 16 * 2 + 1 * 12. Типы, представляющие скалярные числа, показаны в таблицу ниже:

| Тип                   | Описание                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| u8, u16, u32, u64     | Целые числа без знака в диапазоне от 8 до 64 разрядов                                                                                                                    |
| i8, i16, i32, i64<br> | Целые числа со знаком в диапазоне от 8 до 64 разрядов                                                                                                                    |
| f32, f64              | Числа с плавающей точкой в 32-разрядном и 64-разрядном вариантах                                                                                                         |
| isize, usize          | Целые числа, предполагающие "исходную" разрядность центрального процессора. Например, в 64-разрядных центральных процессорах `usize` и `isize` будут шириной 64-разряда. |
 Целые числа со знаком (`i`) представляют собой как отрицательные, так и положительные целые числа.
 Целые числа без знака (`u`) представляют собой только положительные целые числа, но могут быть вдвое шире обычных чисел.
 Типы с плавающей точкой (`f`) представляют собой действительные числа со специальными комбинациями битов для представления значений бесконечности и "не числа".
Ширина целочисленного значения - это количество битов, используемых типом в оперативной памяти или в центральном процессоре.

### Невозможность проведения сравнения разных типов
В Rust существуют требования к безопасности типов, которые не позволяют проводить сравнение между переменными разного типа.

Чтобы компилятор смог сравнить, надо будет воспользоваться оператором `as` для приведения операнда одного типа к другому типу. Например:

```rust
// Код ниже не пройдет компиляцию
fn main() {
	let a: i32 = 10;
	let b: u16 = 100;

	if a < b {
		println!("Ten is less than one hundred.")
	}
}

// Код ниже пройдет компиляцию
fn main() {
	let a: i32 = 10;
	let b: u16 = 100;

	if a < (b as i32) {
		println!("Ten is less than one hundred.")
	}
}
```

Безопаснее всего привести меньший тип к большему (например, 16-разрядный тип к 32-разрядному типу).

Порой использование ключевого слова `as` накладывает слишком больше ограничения. Восстановить более полный контроль над приведением типов можно за счет ряда формальностей. Это выполняет модуль [[TryInto]]:

```rust
use std::convert::TryInto;

fn main() {
	let a: i32 = 10;
	let b: u16 = 100;

	let b_ = b.try_into().unwrap();

	if a < b_ {
		println!("Ten is less than one hundred");
	}
}
```

### Опасности чисел с плавающей точкой
Типы чисел с плавающей точкой (например, `f32` и `f64`) по неосмотрительности могут возникать серьезные проблемы. Этому есть по крайней мере две причины:

1. Зачастую они соответствуют представляемым числам только приблизительно. Типы с плавающей точкой реализованы числами по основанию 2, но вычисления довольно часто требуется проводить в числах по основанию 10. Это несоответствие создает неопределенность. И еще, хотя значения с плавающей точкой описываются как представляющие действительные числа, они имеют ограниченную точность. Для представления всех действительных чисел требуется бесконечная точность.
2. Они могут представлять значения, семантика которых не воспринимается на интуитивном уровне. В отличии от целых чисел, типы с плавающей точкой имеют ряд значений, которые (конструктивно) плохо сочетаются друг с другом. Формально у них только частичное отношение эквивалентности. Все это запрограммировано в системе типов Rust. Для типов `f32` и `f64` реализован только [[Типаж]] `std::cmp::PartialEq`, а для других числовых типов реализован также [[Типаж]] `std::cmp::Eq`.

Для предотвращения опасностей нужно следовать двум рекомендациям:

1. Избегать проверок чисел с плавающей точкой на равенство.
2. Проявлять осторожность, когда результаты могут быть математически неопределенными.

Использование равенства для сравнения чисел с плавающей точкой может быть весьма проблематичным. Числа с плавающей точкой реализованы компьютерными системами, использующие двоичную математику, но от них часто требуется выполнять операции над десятичными числами.

### Рациональные, комплексные и другие
Стандартная библиотека Rust сравнительно невелика по объему. В нее не включены числовые типы, которые часто доступны в других языках. К ним относятся:

 + Многие математические объекты для работы с рациональными и комплексными числами.
 + Целые числа произвольного размера и числа с плавающей точкой произвольной точности для работы с очень большими или маленькими числами.
 + Десятичные числа с фиксированной точкой для работы с валютами.

Для доступа к этим особым числовым типам можно воспользоваться [[Контейнер]]ами или крейтами.

```bash
cargo add num
```

Или отредактируйте файл `Cargo.toml`:

```toml
[dependencies]
num = "0.4"
```

```rust
use num::complex::Complex;

fn main() {
    let a = Complex{re: 1.1, im: -1.2};
    let b = Complex::new(10.1, 22.2);
    let result = a + b;

    println!("{} + {}", result.re, result.im);
}
```