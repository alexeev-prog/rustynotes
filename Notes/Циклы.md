Циклы позволяют управлять ходом выполнения программы.
## Цикл For
Цикл `for` используется для итераций.

```rust
for item in container {
	// ...
}
```

Эта базовая форма делает каждый последующий элемент.

Но, вопреки интуитивным представлениям, как только блок заканчивается, очередной доступ к контейнеру становится некорректным. Несмотря на то, что переменная container остается в локальной области видимости, теперь ее время жизни истекло. Rust считает, что раз блок закончился, потребность в переменной миновала.

В следующий раз при использовании container придется воспользоваться указателем. И опять же, когда указатель опущен, Rust полагает что переменная container больше не нужна.

Чтобы добавить указатель надо поставить знак амперсанда:

```rust
for item in &container {
	// ...
}
```

 > Указатель в программировании - это переменная, в которой хранится адрес памяти объекта.
 
 Если в ходе циклического перебора элементов нужно внести изменения в каждый элемент, можно воспользоваться указателем, допускающим изменения, включив в код ключевое слово `mut`:
 
```rust
for item in &mut collection {
	// ...
}
```

Вдаваясь в подробности реализации Rust-конструкции цикла `for`, следует отметить что она расширяется компилятором в вызов метода. 

| Краткая форма                 | Ее эквивалент                                     | Доступ             |
| ----------------------------- | ------------------------------------------------- | ------------------ |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | По факту владения  |
| `for item in &collection`     | `for item in collection.iter()`                   | Только по чтению   |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | По чтению и записи |

### Безымянные циклы
Если в блоке не используется локальная переменная, то по соглашению применяется знак подчеркивания. Использование этой схемы в сочетании с синтаксисом *_исключающего диапазона_* (`n..m`) и синтаксисом *включающего диапазона* (`n..=m`) показывает, что целью является выполнение цикла фиксированное количество раз. Например:

```rust
for _ in 0..10 {
	// ...
}
```

### Отказ от управления индексной переменной
Во многих языках программирования привычное дело - использование последовательных переборов путем использования временной переменной, увеличивающейся в конце каждой итерации. По соглашению эта переменная называется i.

```rust
let collection = [1, 2, 3, 4, 5];

for i in 0..collection.len() {
	let item = collection[i];
	println!("Item: {}", item);
}
```

Данная схема важна и в тех случаях, когда последовательный перебор `collection` напрямую, с применением кода `for item in collection`, невозможен. Но делать это обычно не рекомендуется. При неавтоматизированном подходе возникают две проблемы:

1. Производительность - индексирование значений с использованием синтаксиса `collection[index]` не обходится без издержек времени выполнения из-за проверки границ. При непосредственном проходе элементов коллекции такая проверка не нужна. Чтобы удостовериться в невозможности запрещенного доступа, компилятор может включить анализ в ход компиляции.
2. Безопасность - периодическое от случая и к случаю обращение к коллекции collection чревато тем, что в нее могут быть внесены изменения . Непосредственное использование в отношении `collection` цикла `for` позволяет Rust гарантировать, что `collection` останется в неприкосновенности со стороны других частей программы.