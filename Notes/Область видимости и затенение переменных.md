## Затенение переменных
В Rust, также как и в большинстве ЯВУ, можно "затенять переменные", то есть создавать вторую переменную с таким же именем, используя значение первой переменной:

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

Эта программа сначала привязывает `x` к значению `5`. Затем она создаёт новую переменную `x`, повторяя `let x =`, беря исходное значение и добавляя `1`, чтобы значение `x` стало равным `6`. Затем во внутренней области видимости, созданной с помощью фигурных скобок, третий оператор `let` также затеняет `x` и создаёт новую переменную, умножая предыдущее значение на `2`, чтобы дать `x` значение `12`. Когда эта область заканчивается, внутреннее затенение заканчивается, и `x` возвращается к значению `6`. Запустив эту программу, она выведет следующее:

```
The value of x in the inner scope is: 12
The value of x is: 6
```

## Область видимости
Связывание переменных происходит в локальной области видимости — они ограничены существованием внутри _блока_. Блок — это набор инструкций, заключённый между фигурными скобками `{}`.

```rust
fn main() {
    // Эта переменная живёт в функции main
	let long_lived_binding = 1;  
	let shadowed_variable = 1;  
	  
	// Это блок, он имеет меньшую область видимости, чем функция main  
	{  
	    // Эта переменная существует только в этом блоке  
	    let short_lived_binding = 2;  
	    let shadowed_variable = 2;  
	  
	    println!("shadowed variable: {}", shadowed_variable);  
	  
	    println!("inner short: {}", short_lived_binding);  
	}  
	// Конец блока  
	println!("shadowed variable: {}", shadowed_variable);  
	  
	println!("outer long: {}", long_lived_binding);
}
```