<!DOCTYPE html>

<html lang="en">

        <head>
                <!-- Page information -->
                <meta charset="UTF-8" />
                <meta name="node_id" content="циклы">
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <link rel="shortcut icon" href="/favicon.ico" />

                <!-- Set title -->
                <title>Obsidian-Html/Notes</title>

                <!-- Includes -->
                <script src="/obs.html/static/obsidian_core.js"></script>
<script src="/obs.html/static/encoding.js"></script>
<link rel="stylesheet" href="/obs.html/static/master.css" />
<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
            'securityLevel': 'loose',
            'theme': 'dark',
            'themeVariables': {
                    'darkMode': true,
            }
    });
</script>
<script>
  MathJax = {
    loader: {
      load: [
        '[tex]/action',
        'output/chtml',
        '[tex]/centernot'
      ]
    },
    tex: {
      inlineMath: [ ["\\(","\\)"] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true,
      processEnvironments: true,
      packages: {'[+]': ['centernot']}
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<script src="/obs.html/static/flexsearch.bundle.js"></script>
<script src="/obs.html/static/pako.js"></script>
<script src="/obs.html/static/search.js"></script>
<script src="/obs.html/static/dirtree.js"></script>




                <!-- Onload tweaks -->
                <script>
                        const CURRENT_NODE = 'циклы';
                        const HTML_URL_PREFIX = '';
                        const PAGE_DEPTH = 0;
                </script>
        </head>

<body class="theme-obs-light">
        <div id="antiflash" style="display: none;"></div>
        <script>
                document.getElementById('antiflash').style.display = 'block';
        </script>
        <div id="search-master-div">
    <div id="search-slab" king_ramses="return the slaaab">
            <div id="search-controls">
                    <input id="search_string" placeholder="Type to search notes" type="text" />
                    <div class="tooltip" style="display: none;">
                        <input type="checkbox" id="hard_search" name="hard" />
                        <span class="tooltiptext">Hard search (require exact match)</span>
                    </div>
                    <div id="search-results-box">
                        <div id="search-results"></div>
                    </div>
                    <div id="search-instructions">
                        <div class="prompt-instruction mobile">
                            <button onclick="toggle_id('search-master-div');"><b>Close</b> Search </button>
                        </div>
                    </div>
            </div>
    </div>
</div>

<script>
    document.getElementById("search-master-div").addEventListener('click', e => {
            if(e.target !== e.currentTarget){
                    return
            }
            toggle_id('search-master-div');
    })
    document.getElementById("search_string").addEventListener("input", function(event) {
            setTimeout( () =>run_search('search_string', 'hard_search'), 100 );
    }); 
    document.getElementById("hard_search").addEventListener("click", function(event) {
            setTimeout( () =>run_search('search_string', 'hard_search'), 100 );
    });

    window.addEventListener('keydown', e => {
        if((e.key=='Escape'||e.key=='Esc'||e.keyCode==27)){
            toggle_id('search-master-div');
            return false;
        } 
    }, true);

    function click_list_link(element){
        element.parentElement.getElementsByTagName('a')[0].click()
    }
</script>

        <div id="page_holder" class="flex_col">
                <div id="header" class="header">
    <div id="header_flex" class="flex_row">
            <a href="/index.html" id="homelink" title="Clear screen and go to homepage">Obsidian-Html/Notes</a>
            <div id="menu_toggle_button" class="navbar-button requires_js" onclick="toggle_menu()">
                    ≡
            </div>
            <div id="navbar" class="navbar requires_js">
                    
                    <div class="icon-tray">
                            <div id="theme-button" class="theme-button requires_js" title="Change theme" onclick="toggle_theme_popup(this)">
    T
</div>
<script>
    function toggle_theme_popup(el){
        // make theme button show that it's active by adding the .active class
        toggle(el);

        // show the theme selector
        toggle_id('theme-popup')

        let h2 = document.getElementById('header2')
        if (h2){
            let pu = document.getElementById('header2').getElementsByClassName('popup')[0];
            toggle(pu);
        }
    }

    function disable_theme_popup(){
        disable_id('theme-button');

        // show the theme selector
        disable_id('theme-popup')

        let h2 = document.getElementById('header2')
        if (h2){
            let pu = document.getElementById('header2').getElementsByClassName('popup')[0];
            disable(pu);
        }
    }
</script>
                                    <div onclick="openSearch()" class="theme-button requires_js">
            <img src = "/obs.html/static/search.svg" alt="Search notes" title="Search notes" style="margin: 4px;"/>
        </div>
        <script>
            function openSearch(){
                // toggle search popup and continue with extra code if it is enabled this time
                if (toggle_id('search-master-div')){
                    // get input field and temporarily disable it
                    let ss = document.getElementById('search_string');
                    ss.value = 'Seach data initializing...';
                    ss.readOnly = true; 

                    // load search data if not yet done so
                    setTimeout(function(){
                        LoadSearchData()

                        // clear input and put focus on it so that we can start typing immediately
                        ss.value = '';
                        ss.readOnly = false; 
                        ss.focus()
                        ss.select()
                    }, 100);
                }
            }
        </script>
                                    <div class="graph_header_div requires_js">
            <a id="graph_link" class="system-link" href="/obs.html/graph/index.html?node=циклы" title="Open fullpage Graph">
                    <img class="graph_header_div_svg" src = "/obs.html/static/graph.svg" alt="Open fullpage Graph" style="margin: 2px; width: 17px;"/>
            </a>
        </div>
                                    <div >
            <a id="dirtree_link" class="system-link" href="/obs.html/dir_index.html" title="View directory tree">
                    <img src = "/obs.html/static/dirtree.svg" style="width: 12px; padding: 4px;" alt="Directory tree link"/>
            </a>
        </div>
                            <div>
    <a href="/obs.html/tags/index.html" title="Open tag view">
            <img src = "/obs.html/static/hashtag.svg" alt="RSS Feed link" style="width: 24px; margin-left: -2px; margin-top: -2px;"/>
    </a>
</div>
                            
                    </div>
                    <div style="display: flex; flex-direction:column">
                        <div id="left_pane_toggle_nav" class="left_pane_toggle_nav">Toggle Directory Tree Pane</div>
                        <div id="right_pane_toggle_nav" class="right_pane_toggle_nav">Toggle Table of Contents Pane</div>
                    </div>
            </div>
    </div>
    <div class="popup" id="theme-popup">
    <label for="cars">Theme </label>

    <select name="theme" id="theme" onchange="set_theme(this.value)">
      <option value="obs-light" selected="selected">obsidian-light</option>
      <option value="obs-dark">obsidian-dark</option>
    </select> 
</div>
</div>
                <div class="flex_row">
                        <div id="left_pane" class="left_pane active">
    <div id="left_pane_fold_header" class="left_pane_fold_header fold_header">x</div>
    <div id="left_pane_content" class="left_pane_content">
            <div id="dirtree"><button id="folder-1" class="dir-button " onclick="toggle_dir(this.id)"><div class="file-icon"></div>Крейты</button>
<div id="folder-container-1" class="dir-container requires_js " path="/Крейты">
	<ul class="dir-list">
		<li><div class="file-icon"></div><a class="" href="/Крейты/Контейнер.html"  >Контейнер</a></li>
	</ul>
</div>
<button id="folder-2" class="dir-button " onclick="toggle_dir(this.id)"><div class="file-icon"></div>Типажи</button>
<div id="folder-container-2" class="dir-container requires_js " path="/Типажи">
	<ul class="dir-list">
		<li><div class="file-icon"></div><a class="" href="/Типажи/TryInto.html"  >TryInto</a></li>
		<li><div class="file-icon"></div><a class="" href="/Типажи/Типаж.html"  >Типаж</a></li>
	</ul>
</div>
<ul class="dir-list">
	<li><div class="file-icon"></div><a class="" href="/Cargo.html"  >Cargo</a></li>
	<li><div class="file-icon"></div><a class="" href="/index.html"  >index</a></li>
	<li><div class="file-icon"></div><a class="" href="/Область видимости и затенение переменных.html"  >Область видимости и затенение переменных</a></li>
	<li><div class="file-icon"></div><a class="" href="/Определение переменных и вызов функций.html"  >Определение переменных и вызов функций</a></li>
	<li><div class="file-icon"></div><a class="" href="/Типы данных.html"  >Типы данных</a></li>
	<li><div class="file-icon"></div><a class="" href="/Условия.html"  >Условия</a></li>
	<li><div class="file-icon"></div><a class="active current_page_dirtree" href="/Циклы.html"  >Циклы</a></li>
</ul>
</div>
    </div>
</div>
                        <div class="container">
                                <div class="content"><h1 id="h__1">Циклы</h1>
<p>Циклы позволяют управлять ходом выполнения программы.   </p>
<h2 id="for">Цикл For</h2>
<p>Цикл <code>for</code> используется для итераций.   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">container</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Эта базовая форма делает каждый последующий элемент в контейнере container доступным в качестве элемента item.   </p>
<p>До edition 2021 если у тебя коллекция (контейнер) был мутабельным, то конструкция for <code>item in collection</code> рассахаривалась в <code>for item collection.into_iter_mut()</code> который "пожирал" твою коллекция, а при добавлении &amp; (амперсенда) он делал <code>item.iter_mut()</code>. Сейчас это всегда <code>item.iter_mut()</code>.    </p>
<p>Так что знак амперсанда - это <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html" class="external-link">итератор</a>.   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">container</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Если в ходе циклического перебора элементов нужно внести изменения в каждый элемент, можно воспользоваться указателем, допускающим изменения, включив в код ключевое слово <code>mut</code>:   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Для того, чтобы пропустить текущую итерацию, можно использовать ключевое слово <code>continue</code>. После вызова этой команды, цикл перейдет к следующей итерации.   </p>
<p>Вдаваясь в подробности реализации Rust-конструкции цикла <code>for</code>, следует отметить что она расширяется компилятором в вызов метода.    </p>
<table>
<thead>
<tr>
<th>Краткая форма</th>
<th>Ее эквивалент</th>
<th>Доступ</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for item in collection</code></td>
<td><code>for item in IntoIterator::into_iter(collection)</code></td>
<td>По факту владения</td>
</tr>
<tr>
<td><code>for item in &amp;collection</code></td>
<td><code>for item in collection.iter()</code></td>
<td>Только по чтению</td>
</tr>
<tr>
<td><code>for item in &amp;mut collection</code></td>
<td><code>for item in collection.iter_mut()</code></td>
<td>По чтению и записи</td>
</tr>
<tr>
<td><code>iter_mut()</code> - один из вариантов IterMut.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### Безымянные циклы</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Если в блоке не используется локальная переменная, то по соглашению применяется знак подчеркивания. Использование этой схемы в сочетании с синтаксисом <em><em>исключающего диапазона</em></em> (<code>n..m</code>) и синтаксисом <em>включающего диапазона</em> (<code>n..=m</code>) показывает, что целью является выполнение цикла фиксированное количество раз. Например:</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>


</div>

<h3 id="h__2">Отказ от управления индексной переменной</h3>
<p>Во многих языках программирования привычное дело - использование последовательных переборов путем использования временной переменной, увеличивающейся в конце каждой итерации. По соглашению эта переменная называется i.   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>

<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">collection</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collection</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Item: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Данная схема важна и в тех случаях, когда последовательный перебор <code>collection</code> напрямую, с применением кода <code>for item in collection</code>, невозможен. Но делать это обычно не рекомендуется. При неавтоматизированном подходе возникают две проблемы:   </p>
<ol>
<li>Производительность - индексирование значений с использованием синтаксиса <code>collection[index]</code> не обходится без издержек времени выполнения из-за проверки границ. При непосредственном проходе элементов коллекции такая проверка не нужна. Чтобы удостовериться в невозможности запрещенного доступа, компилятор может включить анализ в ход компиляции.   </li>
<li>Безопасность - периодическое от случая и к случаю обращение к коллекции collection чревато тем, что в нее могут быть внесены изменения . Непосредственное использование в отношении <code>collection</code> цикла <code>for</code> позволяет Rust гарантировать, что <code>collection</code> останется в неприкосновенности со стороны других частей программы.   </li>
</ol>
<h2 id="while">While</h2>
<p>Цикл while продолжается до тех пор, пока работает условие. Условие, официально известное как "предикат" может быть любым выражением, которое возвращает логическое значение <code>true</code> или <code>false</code>.  Пока условие истинно, цикл выполняется. Когда условие перестаёт быть истинным, программа вызывает <code>break</code>, останавливая цикл.   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">floor</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">floor</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">floor</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Снижаемся на {} этаж&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">floor</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Лифт спустился&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Для перебора элементов коллекции, например, массива, можно использовать конструкцию <code>while</code>.   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;the value is: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Этот код выполняет перебор элементов массива. Он начинается с индекса <code>0</code>, а затем циклически выполняется, пока не достигнет последнего индекса в массиве (то есть, когда <code>index &lt; 5</code> уже не является истиной). Выполнение этого кода напечатает каждый элемент массива:   </p>
<div class="lang-general">

<div class="codehilite"><pre><span></span><code>the value is: 10 the value is: 20 the value is: 30 the value is: 40 the value is: 50
</code></pre></div>


</div>

<p>Все пять значений массива появляются в терминале, как и ожидалось. Поскольку <code>index</code> в какой-то момент достигнет значения <code>5</code>, цикл прекратит выполнение перед попыткой извлечь шестое значение из массива.   </p>
<p>Однако такой подход чреват ошибками; мы можем вызвать панику в программе, если значение индекса или условие проверки неверны. Например, если изменить определение массива <code>a</code> на четыре элемента, но забыть обновить условие на <code>while index &lt; 4</code>, код вызовет панику. Также это медленно, поскольку компилятор добавляет код времени выполнения для обеспечения проверки нахождения индекса в границах массива на каждой итерации цикла.   </p>
<p>В качестве более краткой альтернативы можно использовать цикл <code>for</code> и выполнять некоторый код для каждого элемента коллекции. Цикл <code>for</code> может выглядеть так:   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;the value is: {element}&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>При выполнении этого кода мы увидим тот же результат. Что важнее, теперь мы повысили безопасность кода и устранили вероятность ошибок, которые могут возникнуть в результате выхода за пределы массива или недостаточно далёкого перехода и пропуска некоторых элементов.   </p>
<p>При использовании цикла <code>for</code> не нужно помнить о внесении изменений в другой код, в случае изменения количества значений в массиве, как это было бы с методом, использованным в коде с <code>while</code>.   </p>
<p>Безопасность и компактность циклов <code>for</code> делают их наиболее часто используемой конструкцией цикла в Rust.   </p>
<p>Вот как будет выглядеть обратный отсчёт с использованием цикла <code>for</code> и другого метода, о котором мы ещё не говорили, <code>rev</code>, для разворота диапазона:   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">9</span><span class="p">).</span><span class="n">rev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Спускаемся на {number} этаж&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Лифт спустился.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


</div>

<h2 id="loop">Loop</h2>
<p>Loop - это основа для циклических конструкций в Rust. Ключевое слово <code>loop</code> говорит Rust выполнять блок кода снова и снова до бесконечности или пока не будет явно приказано остановиться.   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;again!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Данная программа выше будет работать бесконечно, пока не будет прервана пользователем.   </p>
<p>К счастью, Rust также предоставляет способ выйти из цикла с помощью кода. Ключевое слово <code>break</code> нужно поместить в цикл, чтобы указать программе, когда следует прекратить выполнение цикла.   </p>
<p>Также существует ключевое слово <code>continue</code> которое пропускает данную итерацию и переходит к следующей.   </p>
<p>Одно из применений <code>loop</code> - это повторение операции, которая может закончиться неудачей, например, проверка успешности выполнения потоком своего задания. Также может понадобиться передать из цикла результат этой операции в остальную часть кода. Для этого можно добавить возвращаемое значение после выражения <code>break</code>, которое используется для остановки цикла. Это значение будет возвращено из цикла, и его можно будет использовать, как показано здесь:   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The result is {result}&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Перед циклом мы объявляем переменную с именем <code>counter</code> и инициализируем её значением <code>0</code>. Затем мы объявляем переменную с именем <code>result</code> для хранения значения, возвращаемого из цикла. На каждой итерации цикла мы добавляем <code>1</code> к переменной <code>counter</code>, а затем проверяем, равняется ли <code>10</code> переменная <code>counter</code>. Когда это происходит, мы используем ключевое слово <code>break</code> со значением <code>counter * 2</code>. После цикла мы ставим точку с запятой для завершения инструкции, присваивающей значение <code>result</code>. Наконец, мы выводим значение в <code>result</code>, равное в данном случае 20.   </p>
<h3 id="h__3">Метки циклов для устранения неоднозначности между несколькими циклами</h3>
<p>Если у вас есть циклы внутри циклов, <code>break</code> и <code>continue</code> применяются к самому внутреннему циклу в этой цепочке. При желании вы можете создать <em>метку цикла</em>, которую вы затем сможете использовать с <code>break</code> или <code>continue</code> для указания, что эти ключевые слова применяются к помеченному циклу, а не к самому внутреннему циклу. Метки цикла должны начинаться с одинарной кавычки. Вот пример с двумя вложенными циклами:   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">counting_up</span><span class="p">:</span><span class="w"> </span><span class="nc">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;count = {count}&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;remaining = {remaining}&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;counting_up</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">remaining</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;End count = {count}&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


</div>

<p>Внешний цикл имеет метку <code>'counting_up</code>, и он будет считать от 0 до 2. Внутренний цикл без метки ведёт обратный отсчёт от 10 до 9. Первый <code>break</code>, который не содержит метку, выйдет только из внутреннего цикла. Инструкция <code>break 'counting_up;</code> завершит внешний цикл. Этот код напечатает:   </p>
<div class="lang-rust">

<div class="codehilite"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">run</span>
<span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">loops</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">:</span><span class="sd">///projects/loops)</span>
<span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="err">`</span><span class="n">dev</span><span class="err">`</span><span class="w"> </span><span class="n">profile</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.58</span><span class="n">s</span>
<span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">loops</span><span class="err">`</span>
<span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span>
<span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span>
<span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="n">End</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
</code></pre></div>


</div>

<hr />
<p>Циклы - довольно интересная вещь в Rust. Они местами отличаются от других языков программирования. Советую попрактиковаться в них.</p></div>
<div class="note-footer">
<div class="backlinks">
<h2>Backlinks</h2>
<ul>
	<li><a class="backlink" href="/index.html">index</a></li>
</ul>
</div>

<div class="tags">

</div>

</div>
<div class="graph requires_js ">
    <div id="A179104583900760041690940711489507530283{level}" class="graph_div"></div>

    <div class="graph-instructions" id="D179104583900760041690940711489507530283{level}">
        Left-click: follow link, Right-click: select node, Scroll: zoom
    </div>
    
    <div class="graph-button-row" style="display:flex;">
        <button class="graph_button graph_show_button" id="B179104583900760041690940711489507530283{level}" level="{level}" note_temp_id="179104583900760041690940711489507530283" onclick="window.ObsHtmlGraph.run(this, '179104583900760041690940711489507530283', 'циклы');">
            Show Graph
        </button>
        <button class="graph_button graph_type_button" id="C179104583900760041690940711489507530283{level}" style="flex:1" onclick="window.ObsHtmlGraph.switch_graph_type(this);">
            2D
        </button>
    </div>
</div>

<script type="module">
    if (window.ObsHtmlGraph == undefined){
        import('/obs.html/static/graph.js').then((Module) => {
            window.ObsHtmlGraph = Module;
            window.ObsHtmlGraph.arm_page(document.getElementById('page_holder'))
        })
    }
</script>




                                <!-- end content -->
                        </div>
                        <div class="container_filler">
                        </div>
                        <div id="right_pane" class="right_pane active">
    <div id="right_pane_fold_header" class="right_pane_fold_header fold_header">x</div>
    <div id="right_pane_content" class="right_pane_content">
            
    </div>
</div>
                </div>
        </div>

        <script>
                function handle_toggle_side_bar(e){
                        let header;
                        let pane; 
                        let target = e.target

                        // switch out the navbar button click for a header click
                        if (target.id == 'left_pane_toggle_nav'){
                                target = document.getElementById('left_pane_fold_header')
                        }
                        else if (target.id == 'right_pane_toggle_nav'){
                                target = document.getElementById('right_pane_fold_header')
                        }

                        // get header and pane
                        if (target.classList.contains('fold_header')) {
                                header = target;
                                pane = target.parentElement;
                        }
                        else {
                                pane = target;
                                header = target.getElementsByClassName('fold_header')[0];
                        }
                        toggle_side_bar(pane, header, true)
                        e.stopPropagation();
                }
                function handle_toggle_side_bar_button(e){
                        document.getElementById('menu_toggle_button').click()
                        handle_toggle_side_bar(e);
                }

                function toggle_side_bar(pane, header, save) {
                        let active = (pane.classList.contains('active'))
                        if (active){
                                disable_side_bar(pane, header, save);
                        }
                        else {
                                enable_side_bar(pane, header, save);
                        }
                }
                function enable_side_bar(pane, header, save){
                        pane.classList.add('active');
                        pane.removeEventListener('click', handle_toggle_side_bar);
                        header.addEventListener('click', handle_toggle_side_bar);
                        set_correct_header_symbol(header);
                        if (save){ save_panel_folding_state(header, true) }
                }
                function disable_side_bar(pane, header, save){
                        pane.classList.remove('active');
                        pane.addEventListener('click', handle_toggle_side_bar);
                        header.removeEventListener('click', handle_toggle_side_bar);
                        set_correct_header_symbol(header);
                        if (save){ save_panel_folding_state(header, false) }
                }
                function set_correct_header_symbol(header){
                        let pane = header.parentElement;
                        let symbol = [['>', '<'],['<', '>']]
                        symbol = symbol[Number(header.classList.contains('right_pane_fold_header'))][Number(pane.classList.contains('active'))];
                        console.log(symbol);
                        header.innerHTML = symbol
                        return header;
                }
                function panel_folding_get_panel_name(header){
                        return ['left', 'right'][Number(header.classList.contains('right_pane_fold_header'))]
                }
                function save_panel_folding_state(header, active){
                        ls_set('pane_folding_state_'+panel_folding_get_panel_name(header), Number(active));
                }
                function load_panel_folding_state(panel_name){
                        val = ls_get('pane_folding_state_'+panel_name)
                        if (!val){ return {'exists': false, 'value': null}}
                        return {'exists': true, 'value': Boolean(Number(val))}
                }
                function set_pane_folding_start(left_header, right_header){
                        // small screen = closed
                        let right_pane_enabled = true;
                        let left_pane_enabled = true;
                        let w = window.visualViewport.width
                        if (w < 1000){
                                left_pane_enabled = false
                        }
                        if (w < 800){
                                right_pane_enabled = false
                        }

                        // get saved values if present
                        let rval = load_panel_folding_state('right')
                        if (rval['exists']){
                                right_pane_enabled = rval['value']
                        }
                        let lval = load_panel_folding_state('left')
                        if (lval['exists']){
                                left_pane_enabled = lval['value']
                        }

                        // default = enabled, so we only need to disable
                        if (!left_pane_enabled){
                                disable_side_bar(document.getElementById('left_pane'), document.getElementById('left_pane_fold_header'))
                        }
                        if (!right_pane_enabled){
                                disable_side_bar(document.getElementById('right_pane'), document.getElementById('right_pane_fold_header'))
                        }
                }

                function init_pane_folding(header){
                        set_correct_header_symbol(header);
                        header.addEventListener('click', handle_toggle_side_bar);
                }
                
                
                set_pane_folding_start()
                init_pane_folding(document.getElementById('left_pane_fold_header'));
                init_pane_folding(document.getElementById('right_pane_fold_header'));

                document.getElementById('left_pane_toggle_nav').addEventListener('click', handle_toggle_side_bar_button);
                document.getElementById('right_pane_toggle_nav').addEventListener('click', handle_toggle_side_bar_button);
        </script>

        <script src="/obs.html/static/load_dirtree_footer.js" type="text/javascript"></script>

        




</body>
</html>
